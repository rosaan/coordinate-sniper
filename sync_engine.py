"""
Local sync engine that watches Convex for new users and creates them in VAEEG.
Uses SQLite for local state tracking.
"""
import os
import sys
import time
from typing import Dict, Any, List
from convex import ConvexClient
from dotenv import load_dotenv
from sequences.create_user import create_user
from local_db import LocalDB, UserStatus
from utils.mysql_check import check_patient_exists

# Load environment variables
load_dotenv(".env.local")

CONVEX_URL = os.getenv("CONVEX_URL")
if not CONVEX_URL:
    print("Error: CONVEX_URL not found in .env.local")
    print("Please set CONVEX_URL in .env.local file")
    sys.exit(1)


def process_user(user: Dict[str, Any], client: ConvexClient, db: LocalDB) -> None:
    """
    Process a single user by creating them in VAEEG and updating Convex.
    
    Args:
        user: User document from Convex
        client: Convex client instance
        db: Local database instance
    """
    user_id = user["_id"]
    client_code = user["clientCode"]
    first_name = user["firstName"]
    last_name = user.get("lastName", "") or ""
    
    # Check if already processed in local DB
    if db.is_user_processed(user_id):
        print(f"[+] Skipping user {user_id} - already processed locally")
        return
    
    # Add to local DB if not exists
    local_user = db.get_user(user_id)
    if not local_user:
        db.add_user(user_id, client_code, first_name, last_name)
    else:
        # Extra safeguard: Skip if already FAILED with MySQL error flag
        if local_user["status"] == UserStatus.FAILED:
            error_msg = local_user.get("error_message", "")
            if "MYSQL_ERROR_DELETED" in error_msg or "MYSQL_ERROR_DELETED_FLAGGED" in error_msg:
                print(f"[+] Skipping user {user_id} - already flagged as FAILED due to MySQL error (create->delete loop prevented)")
                return
    
    # Mark as processing
    db.update_status(user_id, UserStatus.PROCESSING)
    
    # Report processing status to backend
    try:
        client.mutation("user:updateSyncStatus", {
            "userId": user_id,
            "syncStatus": "processing"
        })
    except Exception:
        pass  # Non-critical if this fails
    
    print(f"\n[+] Processing user: {first_name} {last_name} (ID: {user_id})")
    print(f"    Client Code: {client_code} (5-char unique code)")
    
    # Check MySQL database first - if patient already exists, skip creation
    print("    [*] Checking MySQL database for existing patient...")
    try:
        if check_patient_exists(client_code):
            print(f"    [✓] Patient already exists in MySQL - marking as completed")
            
            # Mark as completed in Convex - errors go to errorReason, NOT recordingInstruction
            try:
                client.mutation("user:updateSyncStatus", {
                    "userId": user_id,
                    "syncStatus": "completed",
                    "errorReason": f"Patient already exists in MySQL database (PatientCode: {client_code})"
                })
                # Do NOT call updateRecordingLink - we didn't create a recording link
                # Only update isCreatedLocally flag
                try:
                    # Use a direct patch if needed, but for now just syncStatus update is enough
                    pass
                except Exception:
                    pass
            except Exception as e:
                print(f"    [!] Failed to update Convex: {e}")
            
            # Update local DB - no recording link since we didn't create one
            db.update_status(user_id, UserStatus.COMPLETED, recording_link=None)
            print(f"    [✓] User {user_id} marked as completed (already exists)")
            return
    except Exception as e:
        print(f"    [!] Error checking MySQL: {e}, continuing with creation...")
    
    try:
        # Create user in VAEEG and get recording link
        # Pass the 5-character unique clientCode generated by Convex server to fill the form
        print("    [*] Patient not found in MySQL - starting VAEEG user creation sequence...")
        recording_link = create_user(
            client_id=client_code,
            first_name=first_name,
            last_name=last_name
        )
        
        if recording_link and recording_link.strip():
            print(f"    Recording link: {recording_link}")
            
            # Update user in Convex with the recording link
            try:
                client.mutation("user:updateRecordingLink", {
                    "userId": user_id,
                    "recordingLink": recording_link
                })
                
                # Update local DB
                db.update_status(user_id, UserStatus.COMPLETED, recording_link=recording_link)
                
                print(f"    [✓] Successfully updated user {user_id} with recording link")
            except Exception as update_error:
                # If Convex update fails, still mark as completed locally
                print(f"    [!] Warning: Failed to update Convex: {update_error}")
                db.update_status(user_id, UserStatus.COMPLETED, recording_link=recording_link)
        else:
            error_msg = "Failed to get recording link (empty or None)"
            print(f"    [✗] {error_msg} for user {user_id}")
            retry_count = db.increment_retry(user_id)
            db.update_status(user_id, UserStatus.FAILED, error_message=error_msg)
            print(f"    Retry count: {retry_count}")
            if retry_count >= 3:
                print(f"    [!] Max retries reached for user {user_id}")
            
    except KeyboardInterrupt:
        # User wants to stop - reset status and re-raise
        db.update_status(user_id, UserStatus.PENDING, error_message="Interrupted by user")
        try:
            client.mutation("user:updateSyncStatus", {
                "userId": user_id,
                "syncStatus": "pending",
                "errorReason": "Interrupted by user"
            })
        except Exception:
            pass
        raise
    except RuntimeError as e:
        # Handle specific errors (like DELETE_FAILED, CLIENT_ID_MISMATCH, MYSQL_ERROR_DELETED)
        error_msg = str(e)
        print(f"    [✗] Error processing user {user_id}: {error_msg}")
        
        # Determine status based on error type
        if "CLIPBOARD_COPY_FAILED" in error_msg:
            # Clipboard copy failed - report to backend
            sync_status = "clipboard_copy_failed"
            print(f"    [*] Reporting clipboard copy failure to backend: {sync_status}")
            
            # Report to backend
            try:
                client.mutation("user:updateSyncStatus", {
                    "userId": user_id,
                    "syncStatus": sync_status,
                    "errorReason": error_msg
                })
                print(f"    [✓] Status reported to backend")
            except Exception as backend_error:
                print(f"    [!] Failed to report status to backend: {backend_error}")
            
            # Update local DB
            db.update_status(user_id, UserStatus.FAILED, error_message=error_msg)
            print(f"    [*] User will NOT be retried - requires manual intervention")
            
        elif "MYSQL_ERROR_DELETED" in error_msg or "MYSQL_ERROR_DELETED_FLAGGED" in error_msg:
            # MySQL error - user already deleted from VAEEG, mark as FAILED and STOP retrying
            sync_status = "mysql_error_deleted"
            print(f"    [*] Reporting MySQL error to backend: {sync_status}")
            print(f"    [*] USER FLAGGED - Will NOT be retried (create->delete loop prevented)")
            
            # Mark as FAILED in local DB so it won't be retried
            db.update_status(user_id, UserStatus.FAILED, error_message=error_msg)
            
            # Report to backend
            try:
                client.mutation("user:updateSyncStatus", {
                    "userId": user_id,
                    "syncStatus": sync_status,
                    "errorReason": error_msg
                })
                print(f"    [✓] Status reported to backend")
            except Exception as backend_error:
                print(f"    [!] Failed to report status to backend: {backend_error}")
            
            print(f"    [*] User deleted and FLAGGED as FAILED - will NOT be retried")
            
        elif "DELETE_FAILED" in error_msg or "CLIENT_ID_MISMATCH" in error_msg:
            sync_status = "client_id_mismatch" if "CLIENT_ID_MISMATCH" in error_msg else "delete_failed"
            print(f"    [*] Reporting failure to backend: {sync_status}")
            
            # Report to backend
            try:
                client.mutation("user:updateSyncStatus", {
                    "userId": user_id,
                    "syncStatus": sync_status,
                    "errorReason": error_msg
                })
                print(f"    [✓] Status reported to backend")
            except Exception as backend_error:
                print(f"    [!] Failed to report status to backend: {backend_error}")
            
            # Update local DB
            db.update_status(user_id, UserStatus.FAILED, error_message=error_msg)
            print(f"    [*] User will NOT be retried - requires manual intervention")
        else:
            # Generic error - may retry
            retry_count = db.increment_retry(user_id)
            db.update_status(user_id, UserStatus.FAILED, error_message=error_msg)
            
            # Report to backend
            try:
                client.mutation("user:updateSyncStatus", {
                    "userId": user_id,
                    "syncStatus": "failed",
                    "errorReason": error_msg
                })
            except Exception:
                pass
            
            print(f"    Retry count: {retry_count}")
            if retry_count < 3:
                print(f"    [*] User will be retried on next sync cycle")
            else:
                print(f"    [!] Max retries reached. User will be skipped.")
        
        import traceback
        traceback.print_exception(type(e), e, e.__traceback__)
    except Exception as e:
        error_msg = str(e)
        print(f"    [✗] Error processing user {user_id}: {error_msg}")
        print(f"    [*] This may be due to VAEEG crash or slow system response")
        retry_count = db.increment_retry(user_id)
        db.update_status(user_id, UserStatus.FAILED, error_message=error_msg)
        
        # Report to backend
        try:
            client.mutation("user:updateSyncStatus", {
                "userId": user_id,
                "syncStatus": "failed",
                "errorReason": error_msg
            })
        except Exception:
            pass
        
        print(f"    Retry count: {retry_count}")
        if retry_count < 3:
            print(f"    [*] User will be retried on next sync cycle")
        else:
            print(f"    [!] Max retries reached. User will be skipped.")
        import traceback
        traceback.print_exception(type(e), e, e.__traceback__)


def sync_loop(client: ConvexClient, db: LocalDB) -> None:
    """
    Main sync loop that subscribes to pending users and processes them.
    
    Args:
        client: Convex client instance
        db: Local database instance
    """
    print("[+] Starting sync engine...")
    print(f"[+] Connected to Convex: {CONVEX_URL}")
    print(f"[+] Local database: {db.db_path}")
    print("[+] Listening for new users...")
    print("[+] Press Ctrl+C to stop\n")
    
    # Sync existing users from Convex to local DB
    print("[+] Syncing existing users to local database...")
    try:
        existing_users = client.query("user:listPendingUsers")
        for user in existing_users:
            if not db.get_user(user["_id"]):
                db.add_user(
                    user["_id"],
                    user["clientCode"],
                    user["firstName"],
                    user.get("lastName")
                )
        print(f"[+] Synced {len(existing_users)} users to local database\n")
    except Exception as e:
        print(f"[!] Warning: Could not sync existing users: {e}\n")
    
    try:
        # Subscribe to pending users query
        for users in client.subscribe("user:listPendingUsers"):
            if not users:
                continue
            
            # Process each user
            for user in users:
                user_id = user["_id"]
                sync_status = user.get("syncStatus")
                
                # Check if user has been reset for retry in Convex
                # If Convex says "pending" but local DB says FAILED, reset local status
                local_user = db.get_user(user_id)
                if local_user and sync_status == "pending":
                    if local_user["status"] == UserStatus.FAILED or local_user["status"] == UserStatus.COMPLETED:
                        print(f"[+] User {user_id} reset for retry in Convex - resetting local status...")
                        db.reset_user(user_id)
                        print(f"[✓] Local status reset to PENDING (retry count cleared)")
                
                # Skip if already completed in local DB
                if db.is_user_processed(user_id):
                    continue
                
                # Skip if user is FAILED with MySQL error flag (prevent create->delete loop)
                # UNLESS they've been explicitly reset for retry (syncStatus === "pending")
                if local_user:
                    if local_user["status"] == UserStatus.FAILED:
                        error_msg = local_user.get("error_message", "")
                        if "MYSQL_ERROR_DELETED" in error_msg or "MYSQL_ERROR_DELETED_FLAGGED" in error_msg:
                            # Only skip if NOT reset for retry
                            if sync_status != "pending":
                                print(f"[+] Skipping user {user_id} - flagged as FAILED due to MySQL error (create->delete loop prevented)")
                                continue
                            else:
                                print(f"[+] User {user_id} was reset for retry - will attempt again")
                
                # Process the user
                process_user(user, client, db)
                
                # Extended wait before processing next user (critical for slow laptops)
                # This gives VAEEG time to fully complete operations and prevents crashes
                print("[+] Waiting 15 seconds before next user (allowing VAEEG to stabilize)...")
                time.sleep(15)
                
    except KeyboardInterrupt:
        print("\n[+] Sync engine stopped by user")
    except Exception as e:
        print(f"\n[✗] Sync engine error: {str(e)}")
        import traceback
        traceback.print_exception(type(e), e, e.__traceback__)


def verify_setup(client: ConvexClient) -> bool:
    """
    Verify that Convex connection and MySQL database are working.
    
    Args:
        client: Convex client instance
        
    Returns:
        True if setup is valid, False otherwise
    """
    print("[+] Verifying Convex connection...")
    try:
        # Test query to verify connection
        test_result = client.query("user:listPendingUsers")
        print(f"[✓] Convex connection verified (found {len(test_result)} pending users)")
    except Exception as e:
        print(f"[✗] Failed to verify Convex connection: {e}")
        print(f"[!] Make sure:")
        print(f"    1. CONVEX_URL is correct in .env.local")
        print(f"    2. Convex dev server is running (npx convex dev)")
        print(f"    3. The 'user:listPendingUsers' query exists in convex/user.ts")
        return False
    
    # Verify MySQL connection
    print("[+] Verifying MySQL connection...")
    try:
        from utils.mysql_check import test_mysql_connection
        if not test_mysql_connection():
            print(f"[!] Warning: MySQL connection failed, but continuing anyway")
            print(f"[!] Patient existence checks will be skipped")
        else:
            print(f"[✓] MySQL connection verified")
    except ImportError:
        print(f"[!] Warning: pymysql not installed, MySQL checks will be skipped")
        print(f"[!] Install with: pip install pymysql")
    except Exception as e:
        print(f"[!] Warning: MySQL verification error: {e}")
    
    return True


def main():
    """Main entry point for the sync engine."""
    print("=" * 60)
    print("VAEEG User Sync Engine")
    print("=" * 60)
    
    # Initialize Convex client
    client = ConvexClient(CONVEX_URL)
    
    # Initialize local database
    db = LocalDB()
    print(f"[✓] Local database initialized: {db.db_path}")
    
    # Verify setup
    if not verify_setup(client):
        print("\n[✗] Setup verification failed. Please fix the issues above.")
        sys.exit(1)
    
    print()
    
    # Start sync loop
    sync_loop(client, db)


if __name__ == "__main__":
    main()

