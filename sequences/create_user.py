"""
Sequence for creating a new user in the VAEEG application.
"""
from utils import click, click_and_type, wait, get_clipboard, wait_for_element_ready, wait_for_clipboard_change
from utils.app_manager import connect_or_start, bring_up_window, find_and_close_error_dialog
from sequences.delete_user import delete_user

# Coordinate definitions for the create user flow
CREATE_USER_BTN = (442.5, 205.0)
CLIENT_ID = (436.25, 380.0)
FIRST_NAME = (468.75, 481.25)
LAST_NAME = (631.25, 481.25)
SAVE_BTN = (677.5, 208.75)
RECORDING_LINK_COPY = (1023.75, 386.25)
CLOSE_LINK_CODE = (1303.75, 213.75)

# Application configuration
EXE_PATH = r"C:\\Program Files (x86)\\VAEEG\\VA.exe"
WINDOW_TITLE_REGEX = r"VAEEG - \[Client\]"


def create_user(client_id: str, first_name: str, last_name: str, 
                exe_path: str = EXE_PATH, 
                window_title_regex: str = WINDOW_TITLE_REGEX) -> str:
    """
    Create a new user and retrieve the recording link.
    The client_id is auto-generated as a unique 5-character code on the Convex server, then passed here to fill the form.
    
    Optimized for slow laptops with extended delays to prevent VAEEG crashes.
    
    Args:
        client_id: Client ID (5-character unique code) generated by Convex server
        first_name: First name for the user
        last_name: Last name for the user
        exe_path: Path to the VAEEG executable
        window_title_regex: Regex pattern to match the window title
        
    Returns:
        The recording link URL
    """
    # Connect to or start the application
    app = connect_or_start(exe_path)
    win = bring_up_window(app, window_title_regex)
    
    # Give the app time to stabilize after startup
    wait(1)
    
    # Ensure main window is focused and ready before actions
    try:
        win.set_focus()
        win.wait("visible enabled", timeout=3.0)
        wait(0.5)  # Ensure window is fully focused
    except Exception:
        pass  # Continue anyway
    
    # Ensure VAEEG is closed at the end, even if there's an error
    try:
        # Execute the create user sequence
        print("    [*] Clicking create user button...")
        click(CREATE_USER_BTN, delay=0.3)
        wait(1.0)  # Wait for form to load and be ready
        
        print("    [*] Filling client ID...")
        click_and_type(CLIENT_ID, client_id, type_interval=0.02, delay=0.3)
        wait(0.3)  # Wait between fields to ensure field is ready
        
        print("    [*] Filling first name...")
        click_and_type(FIRST_NAME, first_name, type_interval=0.02, delay=0.3)
        wait(0.3)  # Wait between fields to ensure field is ready
        
        print("    [*] Filling last name...")
        click_and_type(LAST_NAME, last_name, type_interval=0.02, delay=0.3)
        wait(0.5)  # Wait before save to ensure form is ready
        
        # Save with retry logic to handle SQL error popups
        print("    [*] Saving user (with error handling)...")
        max_save_retries = 10
        save_retry_count = 0
        link_dialog_ready = False
        
        while save_retry_count < max_save_retries and not link_dialog_ready:
            save_retry_count += 1
            
            # Click save button
            print(f"    [*] Save attempt {save_retry_count}/{max_save_retries}...")
            # Ensure window is focused before saving
            try:
                win.set_focus()
                wait(0.2)
            except Exception:
                pass
            click(SAVE_BTN, delay=0.3)
            wait(2.0)  # Wait for either success or error dialog to appear
            
            # FIRST check if "Patient link code" window appeared (success!)
            # Only check for errors if success window is NOT found
            success_window_found = False
            try:
                test_link_window = app.window(title_re="Patient link code")
                test_link_window.wait("exists", timeout=1.0)
                success_window_found = True
                print("    [✓] Success window found - no error!")
            except Exception:
                pass
            
            # Only check for SQL errors if success window was NOT found
            error_dialog_found = False
            if not success_window_found:
                # Check for error dialog popup with MORE SPECIFIC keywords
                # Only match actual SQL/MySQL error messages, not generic warnings
                for check_attempt in range(3):
                    error_dialog_found = find_and_close_error_dialog(
                        app, 
                        error_keywords=[
                            "mysql error",
                            "sql error", 
                            "database error",
                            "mysql exception",
                            "sql exception",
                            "connection lost",
                            "gone away",
                            "mysql server",
                            "access denied",
                            "duplicate entry"
                        ],
                        timeout=1.5
                    )
                    if error_dialog_found:
                        break
                    wait(0.5)  # Wait before checking again
            else:
                # Success window found, no need to check for errors
                link_dialog_ready = True
                break
            
            if error_dialog_found:
                print(f"    [!] MySQL/SQL error detected!")
                print(f"    [*] Deleting user with client ID: {client_id} from VAEEG...")
                
                try:
                    # Delete the user that caused the error
                    delete_success = delete_user(client_id, exe_path, window_title_regex)
                    
                    if not delete_success:
                        print(f"    [✗] Delete operation failed!")
                        raise RuntimeError(f"MYSQL_ERROR_DELETE_FAILED: Could not delete user from VAEEG")
                    
                    print(f"    [✓] User deleted from VAEEG successfully")
                    print(f"    [*] MySQL error occurred - user deleted and flagged")
                    print(f"    [*] STOPPING - User will be marked as FAILED and NOT retried")
                    
                    # Raise exception to signal sync_engine to mark as FAILED and stop retrying
                    error_reason = f"MySQL error occurred. User deleted from VAEEG. Client ID: {client_id}. User flagged - do not retry."
                    raise RuntimeError(f"MYSQL_ERROR_DELETED_FLAGGED: {error_reason}")
                    
                except RuntimeError as e:
                    # Re-raise if it's already our error
                    if "MYSQL_ERROR" in str(e):
                        raise
                    # Otherwise wrap it
                    raise RuntimeError(f"MYSQL_ERROR_DELETE_FAILED: {str(e)}")
                except Exception as e:
                    print(f"    [✗] Error during delete: {e}")
                    raise RuntimeError(f"MYSQL_ERROR_DELETE_FAILED: {str(e)}")
            
            # If no error was found, check again for "Patient link code" window (success!)
            # This handles the case where success window appears after error check
            if not error_dialog_found:
                print("    [*] Waiting for 'Patient link code' window to appear...")
                try:
                    # Wait for the window to appear
                    link_window = app.window(title_re="Patient link code")
                    link_window.wait("exists", timeout=5.0)
                    print("    [✓] 'Patient link code' window appeared - save successful!")
                    link_dialog_ready = True
                    break
                except Exception:
                    # Window not found yet, wait and check again
                    wait(0.5)
                    try:
                        link_window = app.window(title_re="Patient link code")
                        link_window.wait("exists", timeout=3.0)
                        print("    [✓] 'Patient link code' window appeared after extended wait - save successful!")
                        link_dialog_ready = True
                        break
                    except Exception:
                        pass
        
        # Final check - wait longer if window still not ready
        if link_window is None:
            print("    [*] Waiting for 'Patient link code' window (extended wait)...")
            try:
                link_window = app.window(title_re="Patient link code")
                link_window.wait("exists", timeout=8.0)
                print("    [✓] 'Patient link code' window found")
            except Exception as e:
                print(f"    [!] 'Patient link code' window not found: {e}")
                raise RuntimeError("Failed to find 'Patient link code' window after save")
        
        # Focus the "Patient link code" window
        print("    [*] Focusing 'Patient link code' window...")
        try:
            link_window.set_focus()
            link_window.wait("visible enabled", timeout=5.0)
            wait(0.8)  # Give window time to fully focus and be ready for interaction
            print("    [✓] Window focused and ready")
        except Exception as e:
            print(f"    [!] Warning: Could not focus window: {e}")
            # Try to bring it up using bring_up_window method
            try:
                bring_up_window(app, "Patient link code", timeout=5.0, maximize=False)
                wait(0.8)
            except Exception:
                pass
        
        # Get current clipboard content before copying (to detect change)
        clipboard_before = get_clipboard()
        print(f"    [*] Current clipboard (before copy): {clipboard_before[:50]}..." if len(clipboard_before) > 50 else f"    [*] Current clipboard (before copy): {clipboard_before}")
        
        # Prepare verification strings (normalized for comparison)
        first_name_lower = first_name.lower().strip()
        last_name_lower = last_name.lower().strip() if last_name else ""
        print(f"    [*] Will verify clipboard contains: '{first_name}' or '{last_name}'")
        
        # Improved clipboard copy with reliable change detection
        url = None
        max_retries = 10  # Reduced retries but with better reliability
        retry_count = 0
        
        while retry_count < max_retries and url is None:
            retry_count += 1
            print(f"    [*] Copy attempt {retry_count}/{max_retries}...")
            
            try:
                # Method 1: Click copy button and wait for clipboard change
                print("    [*] Clicking copy button in 'Patient link code' window...")
                # Ensure window is still focused before clicking
                try:
                    link_window.set_focus()
                    wait(0.3)
                except Exception:
                    pass
                click(RECORDING_LINK_COPY, delay=0.3)
                
                # Wait for clipboard to actually change (more reliable than fixed wait)
                try:
                    print("    [*] Waiting for clipboard to change...")
                    new_clipboard = wait_for_clipboard_change(
                        initial_content=clipboard_before,
                        timeout=3.0,
                        check_interval=0.1
                    )
                    print(f"    [✓] Clipboard changed detected!")
                except TimeoutError:
                    print(f"    [!] Clipboard didn't change after clicking copy button, trying alternative...")
                    # Method 2: Try Ctrl+C as alternative
                    try:
                        import pyautogui
                        # Focus the window first
                        link_window.set_focus()
                        wait(0.5)  # Ensure window is focused
                        # Select all and copy
                        pyautogui.hotkey("ctrl", "a")
                        wait(0.2)  # Wait for selection
                        pyautogui.hotkey("ctrl", "c")
                        wait(0.3)  # Wait for copy to complete
                        # Wait for clipboard change
                        new_clipboard = wait_for_clipboard_change(
                            initial_content=clipboard_before,
                            timeout=2.0,
                            check_interval=0.1
                        )
                        print(f"    [✓] Clipboard changed via Ctrl+C!")
                    except TimeoutError:
                        if retry_count < max_retries:
                            print(f"    [!] Clipboard still didn't change, retrying...")
                            wait(0.5)
                            continue
                        else:
                            raise RuntimeError(f"CLIPBOARD_COPY_FAILED: Could not copy link after {max_retries} attempts. Clipboard unchanged.")
                
                # Verify clipboard contains user's first or last name
                clipboard_lower = new_clipboard.lower()
                contains_first_name = first_name_lower in clipboard_lower if first_name_lower else False
                contains_last_name = last_name_lower in clipboard_lower if last_name_lower else False
                
                if contains_first_name or contains_last_name:
                    url = new_clipboard.strip()
                    print(f"    [✓] Clipboard verified - contains user data!")
                    if contains_first_name:
                        print(f"    [✓] Found first name '{first_name}' in clipboard")
                    if contains_last_name:
                        print(f"    [✓] Found last name '{last_name}' in clipboard")
                    print(f"    [✓] Link: {url[:100]}..." if len(url) > 100 else f"    [✓] Link: {url}")
                    break
                else:
                    print(f"    [!] Clipboard changed but doesn't contain user data")
                    print(f"    [*] Looking for: '{first_name}' or '{last_name}'")
                    print(f"    [*] Clipboard content: {new_clipboard[:150]}..." if len(new_clipboard) > 150 else f"    [*] Clipboard content: {new_clipboard}")
                    
                    if retry_count < max_retries:
                        # Update baseline and try again
                        clipboard_before = new_clipboard
                        wait(0.5)
                        continue
                    else:
                        # Max retries reached - report failure
                        raise RuntimeError(f"CLIPBOARD_COPY_FAILED: Clipboard content doesn't contain user data after {max_retries} attempts. Got: '{new_clipboard[:100]}...'")
                        
            except RuntimeError as e:
                # Re-raise our specific errors
                if "CLIPBOARD_COPY_FAILED" in str(e):
                    raise
                # Otherwise continue retrying
                if retry_count < max_retries:
                    print(f"    [!] Error: {e}, retrying...")
                    wait(0.5)
                    continue
                else:
                    raise RuntimeError(f"CLIPBOARD_COPY_FAILED: {str(e)}")
            except Exception as e:
                if retry_count < max_retries:
                    print(f"    [!] Unexpected error: {e}, retrying...")
                    wait(0.5)
                    continue
                else:
                    raise RuntimeError(f"CLIPBOARD_COPY_FAILED: Unexpected error after {max_retries} attempts: {str(e)}")
        
        # Final verification - if we still don't have a URL, it's a failure
        if url is None:
            final_clipboard = get_clipboard()
            if final_clipboard == clipboard_before:
                raise RuntimeError(f"CLIPBOARD_COPY_FAILED: Clipboard content didn't change at all after {max_retries} attempts. Expected to find '{first_name}' or '{last_name}'")
            else:
                # Last check - maybe it does contain user data but our verification is too strict
                final_lower = final_clipboard.lower()
                if (first_name_lower in final_lower if first_name_lower else False) or \
                   (last_name_lower in final_lower if last_name_lower else False):
                    url = final_clipboard.strip()
                    print(f"    [✓] Final check successful - found user data in clipboard")
                else:
                    raise RuntimeError(f"CLIPBOARD_COPY_FAILED: Could not verify clipboard contains user data. Got: '{final_clipboard[:100]}...'")
        
        print("    [*] Closing link dialog...")
        click(CLOSE_LINK_CODE, delay=0.2)
        wait(0.3)  # Wait for dialog to close
        
        return url
    finally:
        # Always close VAEEG application after sequence completes (even on error)
        from utils.app_manager import close_application
        close_application(app, exe_path)
