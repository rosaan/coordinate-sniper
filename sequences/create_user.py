"""
Sequence for creating a new user in the VAEEG application.
"""
from utils import click, click_and_type, wait, get_clipboard, wait_for_element_ready, wait_for_clipboard_change
from utils.app_manager import connect_or_start, bring_up_window, find_and_close_error_dialog
from sequences.delete_user import delete_user

# Coordinate definitions for the create user flow
CREATE_USER_BTN = (442.5, 205.0)
CLIENT_ID = (436.25, 380.0)
FIRST_NAME = (468.75, 481.25)
LAST_NAME = (631.25, 481.25)
SAVE_BTN = (677.5, 208.75)
RECORDING_LINK_COPY = (1023.75, 386.25)
CLOSE_LINK_CODE = (1303.75, 213.75)

# Application configuration
EXE_PATH = r"C:\\Program Files (x86)\\VAEEG\\VA.exe"
WINDOW_TITLE_REGEX = r"VAEEG - \[Client\]"


def create_user(client_id: str, first_name: str, last_name: str, 
                exe_path: str = EXE_PATH, 
                window_title_regex: str = WINDOW_TITLE_REGEX) -> str:
    """
    Create a new user and retrieve the recording link.
    The client_id is auto-generated as a unique 5-character code on the Convex server, then passed here to fill the form.
    
    Optimized for slow laptops with extended delays to prevent VAEEG crashes.
    
    Args:
        client_id: Client ID (5-character unique code) generated by Convex server
        first_name: First name for the user
        last_name: Last name for the user
        exe_path: Path to the VAEEG executable
        window_title_regex: Regex pattern to match the window title
        
    Returns:
        The recording link URL
    """
    # Connect to or start the application
    app = connect_or_start(exe_path)
    win = bring_up_window(app, window_title_regex)
    
    # Give the app extra time to stabilize after startup (critical for slow laptops)
    wait(3)
    
    # Execute the create user sequence with extended delays
    print("    [*] Clicking create user button...")
    click(CREATE_USER_BTN, delay=0.5)
    wait(2)  # Wait for form to load
    
    print("    [*] Filling client ID...")
    click_and_type(CLIENT_ID, client_id, type_interval=0.05, delay=1.5)
    wait(1)  # Extra wait between fields
    
    print("    [*] Filling first name...")
    click_and_type(FIRST_NAME, first_name, type_interval=0.05, delay=1.5)
    wait(1)  # Extra wait between fields
    
    print("    [*] Filling last name...")
    click_and_type(LAST_NAME, last_name, type_interval=0.05, delay=1.5)
    wait(1)  # Extra wait before save
    
    # Save with retry logic to handle SQL error popups
    print("    [*] Saving user (with error handling)...")
    max_save_retries = 10
    save_retry_count = 0
    link_dialog_ready = False
    
    while save_retry_count < max_save_retries and not link_dialog_ready:
        save_retry_count += 1
        
        # Click save button
        print(f"    [*] Save attempt {save_retry_count}/{max_save_retries}...")
        click(SAVE_BTN, delay=0.5)
        wait(2)  # Wait a bit for either success or error dialog
        
        # Check for error dialog popup
        error_dialog_found = find_and_close_error_dialog(app, timeout=2.0)
        
        if error_dialog_found:
            print(f"    [!] SQL error detected! Need to delete user and retry...")
            print(f"    [*] Deleting user with client ID: {client_id}")
            
            try:
                # Delete the user that caused the error
                delete_user(client_id, exe_path, window_title_regex)
                wait(2)  # Wait after deletion
                
                # Re-open the create user form
                print("    [*] Re-opening create user form...")
                click(CREATE_USER_BTN, delay=0.5)
                wait(2)  # Wait for form to load
                
                # Re-fill the form
                print("    [*] Re-filling form fields...")
                click_and_type(CLIENT_ID, client_id, type_interval=0.05, delay=1.5)
                wait(1)
                click_and_type(FIRST_NAME, first_name, type_interval=0.05, delay=1.5)
                wait(1)
                click_and_type(LAST_NAME, last_name, type_interval=0.05, delay=1.5)
                wait(1)
                
                print("    [*] Retrying save after deletion...")
                # Continue to next iteration to try save again
                continue
            except Exception as e:
                print(f"    [✗] Error during delete/retry: {e}")
                print("    [*] Will retry save anyway...")
                wait(1)
                continue
        
        # Check if link dialog appeared (success!)
        print("    [*] Checking if link dialog appeared...")
        link_dialog_ready = wait_for_element_ready(
            RECORDING_LINK_COPY, 
            timeout=3.0,  # Quick check
            check_interval=0.3,
            stable_duration=0.5
        )
        
        if link_dialog_ready:
            print("    [✓] Link dialog appeared - save successful!")
            break
        else:
            # Wait a bit more and check again (in case it's slow)
            wait(2)
            link_dialog_ready = wait_for_element_ready(
                RECORDING_LINK_COPY, 
                timeout=2.0,
                check_interval=0.3,
                stable_duration=0.5
            )
            if link_dialog_ready:
                print("    [✓] Link dialog appeared after extended wait - save successful!")
                break
    
    # Final check - wait longer if dialog still not ready
    if not link_dialog_ready:
        print("    [*] Waiting for link dialog to appear (extended wait)...")
        link_dialog_ready = wait_for_element_ready(
            RECORDING_LINK_COPY, 
            timeout=10.0,  # Extended timeout for slow laptops
            check_interval=0.5,
            stable_duration=1.0  # Dialog must be stable for 1 second
        )
        
        if not link_dialog_ready:
            print("    [!] Link dialog may not be ready, waiting additional time...")
            wait(3)  # Fallback wait
            # Check one more time
            link_dialog_ready = wait_for_element_ready(
                RECORDING_LINK_COPY, 
                timeout=5.0,
                check_interval=0.5,
                stable_duration=0.5
            )
    
    # Get current clipboard content before copying (to detect change)
    clipboard_before = get_clipboard()
    print(f"    [*] Current clipboard (before copy): {clipboard_before[:50]}..." if len(clipboard_before) > 50 else f"    [*] Current clipboard (before copy): {clipboard_before}")
    
    # Prepare verification strings (normalized for comparison)
    first_name_lower = first_name.lower().strip()
    last_name_lower = last_name.lower().strip() if last_name else ""
    print(f"    [*] Will verify clipboard contains: '{first_name}' or '{last_name}'")
    
    print("    [*] Copying recording link...")
    click(RECORDING_LINK_COPY, delay=0.5)
    wait(0.5)  # Give copy operation time to complete
    
    # Wait for clipboard to change AND verify it contains user data
    print("    [*] Waiting for clipboard to update and verify content...")
    url = None
    max_retries = 15  # Increased retries for slow systems
    retry_count = 0
    
    while retry_count < max_retries and url is None:
        try:
            # Wait for clipboard to change from previous state
            new_clipboard = wait_for_clipboard_change(
                initial_content=clipboard_before,
                timeout=3.0,  # Per attempt timeout
                check_interval=0.2
            )
            
            # Verify clipboard contains user's first or last name
            # This ensures we got the correct link for this user
            clipboard_lower = new_clipboard.lower()
            
            contains_first_name = first_name_lower in clipboard_lower if first_name_lower else False
            contains_last_name = last_name_lower in clipboard_lower if last_name_lower else False
            
            if contains_first_name or contains_last_name:
                url = new_clipboard
                print(f"    [✓] Clipboard verified - contains user data!")
                if contains_first_name:
                    print(f"    [✓] Found first name '{first_name}' in clipboard")
                if contains_last_name:
                    print(f"    [✓] Found last name '{last_name}' in clipboard")
                print(f"    [✓] Link: {url[:100]}..." if len(url) > 100 else f"    [✓] Link: {url}")
                break
            else:
                retry_count += 1
                print(f"    [!] Attempt {retry_count}/{max_retries}: Clipboard changed but doesn't contain user data")
                print(f"    [*] Looking for: '{first_name}' or '{last_name}'")
                print(f"    [*] Clipboard content: {new_clipboard[:100]}..." if len(new_clipboard) > 100 else f"    [*] Clipboard content: {new_clipboard}")
                
                if retry_count < max_retries:
                    # Update baseline to the new (wrong) content and try again
                    clipboard_before = new_clipboard
                    wait(1.0)  # Wait before retrying
                    # Click copy again
                    print("    [*] Re-clicking copy button...")
                    click(RECORDING_LINK_COPY, delay=0.5)
                    wait(0.5)  # Give copy operation time
        except TimeoutError:
            retry_count += 1
            print(f"    [!] Attempt {retry_count}/{max_retries}: Clipboard didn't change")
            if retry_count < max_retries:
                wait(1.0)
                print("    [*] Re-clicking copy button...")
                click(RECORDING_LINK_COPY, delay=0.5)
                wait(0.5)  # Give copy operation time
    
    # Final fallback: try to get clipboard one more time
    if url is None:
        print("    [✗] ERROR: Could not verify clipboard contains user data after all retries!")
        print("    [*] Getting clipboard content as fallback...")
        final_clipboard = get_clipboard()
        
        if final_clipboard == clipboard_before:
            print("    [✗] CRITICAL ERROR: Clipboard content didn't change at all!")
            raise RuntimeError(f"Failed to copy link - clipboard unchanged. Expected to find '{first_name}' or '{last_name}'")
        else:
            # Last attempt: check if it contains user data
            final_lower = final_clipboard.lower()
            if (first_name_lower in final_lower if first_name_lower else False) or \
               (last_name_lower in final_lower if last_name_lower else False):
                url = final_clipboard
                print(f"    [✓] Fallback successful - found user data in clipboard")
            else:
                print(f"    [✗] WARNING: Got unverified link that doesn't contain user data")
                print(f"    [*] Unverified link: {final_clipboard[:100]}..." if len(final_clipboard) > 100 else f"    [*] Unverified link: {final_clipboard}")
                url = final_clipboard  # Still return it, but warn
    
    print("    [*] Closing link dialog...")
    click(CLOSE_LINK_CODE, delay=0.5)
    wait(1)  # Wait for dialog to close
    
    return url
